apiVersion: helm.toolkit.fluxcd.io/v2beta1
kind: HelmRelease
metadata:
  name: proc-ades
  namespace: proc
spec:
  chart:
    spec:
      chart: ades
      version: 2.0.12
      sourceRef:
        kind: HelmRepository
        name: eoepca
        namespace: common
  values:
    # values - start
    replicaCount: 1
    image:
      pullPolicy: Always
      # Overrides the image tag whose default is the chart appVersion.
      tag: "dev2.0.15"
    nameOverride: ""
    fullnameOverride: ""
    serviceAccount:
      # Specifies whether a service account should be created
      create: true
      # Annotations to add to the service account
      annotations: {}
      # The name of the service account to use.
      # If not set and create is true, a name is generated using the fullname template
      name: ""
    podAnnotations: {}
    podSecurityContext:
      {}
      # fsGroup: 2000
    securityContext:
      {}
      # capabilities:
      #   drop:
      #   - ALL
      # readOnlyRootFilesystem: true
      # runAsNonRoot: true
      # runAsUser: 1000
    service:
      type: ClusterIP
      port: 80
    ingress:
      enabled: true
      annotations: {}
      hosts:
        - host: ades-open.develop.eoepca.org
          paths:
            - path: /
              pathType: ImplementationSpecific    
      tls: []
      #  - secretName: chart-example-tls
      #    hosts:
      #      - chart-example.local
    resources:
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'.
      limits:
        cpu: 2
        memory: 4Gi
      requests:
        cpu: 500m
        memory: 2Gi
    autoscaling:
      enabled: false
      minReplicas: 1
      maxReplicas: 3
      targetCPUUtilizationPercentage: 80
      # targetMemoryUtilizationPercentage: 80
    storageClassName: managed-nfs-storage
    clusterAdminRoleName: cluster-admin
    nodeSelector: {}
    tolerations: []
    affinity: {}
    useKubeProxy: True
    workflowExecutor:
      # Necessary if useKubeProxy set to false
      # kubeconfig: "files/kubeconfig"

      # Here specify fixed inputs to all workflows execution in all stages (main, stage-in/out)
      # They will be prefixed with 'ADES_'. e.g. 'APP: ades' will be 'ADES_APP: ades'
      inputs:
        APP: ades

        STAGEIN_AWS_SERVICEURL: http://data.cloudferro.com
        STAGEIN_AWS_ACCESS_KEY_ID: test
        STAGEIN_AWS_SECRET_ACCESS_KEY: test
        STAGEIN_AWS_REGION: RegioneOne

        STAGEOUT_AWS_SERVICEURL: https://minio.develop.eoepca.org

      useResourceManager: "false"
      resourceManagerWorkspacePrefix: "develop-user"
      resourceManagerEndpoint: "https://workspace-api.develop.eoepca.org"
      platformDomain: "https://auth.develop.eoepca.org"

      pod_env_vars:
        yaml: "{}"

      usernameJwtJsonPath: "test.user_name"

      main:
          cwl: |
              class: Workflow
              $namespaces:
                  cwltool: http://commonwl.org/cwltool#
              doc: Main stage manager
              id: main
              label: macro-cwl
              inputs: {}
              outputs: {}
              hints:
                  "cwltool:Secrets":
                      secrets: []
              requirements:
                  SubworkflowFeatureRequirement: {}
                  ScatterFeatureRequirement: {}
                  InlineJavascriptRequirement: {}

      stageout:
        cwl: |
              cwlVersion: v1.0
              baseCommand: ['/bin/bash', 'stageout.sh']
              doc: "Run Stars for staging results"
              class: CommandLineTool
              hints:
                DockerRequirement:
                  dockerPull: terradue/stars:2.3.1
                "cwltool:Secrets":
                  secrets:
                  - ADES_STAGEOUT_AWS_SERVICEURL
                  - ADES_STAGEOUT_AWS_REGION
                  - ADES_STAGEOUT_AWS_ACCESS_KEY_ID
                  - ADES_STAGEOUT_AWS_SECRET_ACCESS_KEY
              id: stars
              arguments:
                - copy
                - -v
                - -r
                - '4'
                - -o
                - $( inputs.ADES_STAGEOUT_OUTPUT + "/" + inputs.process )
                - -res
                - $( inputs.process + ".res" )
                - valueFrom: |
                          ${
                              if( !Array.isArray(inputs.wf_outputs) ) 
                              {
                                  return inputs.wf_outputs.path + "/catalog.json";
                              }
                              var args=[];
                              for (var i = 0; i < inputs.wf_outputs.length; i++) 
                              {
                                  args.push(inputs.wf_outputs[i].path + "/catalog.json");
                              }
                              return args;
                          }
              inputs: 
                ADES_STAGEOUT_AWS_PROFILE:
                  type: string?
                ADES_STAGEOUT_AWS_SERVICEURL: 
                  type: string?
                ADES_STAGEOUT_AWS_ACCESS_KEY_ID: 
                  type: string?
                ADES_STAGEOUT_AWS_SECRET_ACCESS_KEY: 
                  type: string?
                aws_profiles_location:
                  type: File?
                ADES_STAGEOUT_OUTPUT:
                  type: string?
                ADES_STAGEOUT_AWS_REGION:
                  type: string?
                process:
                  type: string?
              outputs: 
                StacCatalogUri:
                  outputBinding:
                    outputEval: ${  return inputs.ADES_STAGEOUT_OUTPUT + "/" + inputs.process + "/catalog.json"; }
                  type: string
              requirements:
                InitialWorkDirRequirement:
                  listing:
                  - entryname: stageout.sh
                    entry: |-
                      #!/bin/bash
                      export AWS__ServiceURL=$(inputs.ADES_STAGEOUT_AWS_SERVICEURL)
                      export AWS__Region=$(inputs.ADES_STAGEOUT_AWS_REGION)
                      export AWS__AuthenticationRegion=$(inputs.ADES_STAGEOUT_AWS_REGION)
                      export AWS_ACCESS_KEY_ID=$(inputs.ADES_STAGEOUT_AWS_ACCESS_KEY_ID)
                      export AWS_SECRET_ACCESS_KEY=$(inputs.ADES_STAGEOUT_AWS_SECRET_ACCESS_KEY)
                      Stars $@
                InlineJavascriptRequirement: {}
                EnvVarRequirement:
                  envDef:
                    PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
                ResourceRequirement: {}



      stagein:
        cwl: |
          cwlVersion: v1.0
          doc: "Run Stars for staging input data"
          class: CommandLineTool
          hints:
            DockerRequirement:
              dockerPull: terradue/stars:1.0.0-beta.11
            "cwltool:Secrets":
              secrets:
              - ADES_STAGEIN_AWS_SERVICEURL
              - ADES_STAGEIN_AWS_ACCESS_KEY_ID
              - ADES_STAGEIN_AWS_SECRET_ACCESS_KEY
          id: stars
          inputs:
            ADES_STAGEIN_AWS_SERVICEURL:
              type: string?
            ADES_STAGEIN_AWS_ACCESS_KEY_ID:
              type: string?
            ADES_STAGEIN_AWS_SECRET_ACCESS_KEY:
              type: string?
          outputs: {}
          baseCommand: ['/bin/bash', 'stagein.sh']
          requirements:
            InitialWorkDirRequirement:
              listing:
              - entryname: stagein.sh
                entry: |-
                  #!/bin/bash
                  export AWS__ServiceURL=$(inputs.ADES_STAGEIN_AWS_SERVICEURL)
                  export AWS_ACCESS_KEY_ID=$(inputs.ADES_STAGEIN_AWS_ACCESS_KEY_ID)
                  export AWS_SECRET_ACCESS_KEY=$(inputs.ADES_STAGEIN_AWS_SECRET_ACCESS_KEY)
                  url=$1
                  if curl --output /dev/null --silent --head --fail "$url"; then
                    echo "URL: $url"
                  else
                    echo "URL does not exist: $url"
                    exit 1
                  fi
                  Stars copy -v -rel -r 4 -o ./ --harvest $url
            EnvVarRequirement:
              envDef:
                PATH: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
            ResourceRequirement: {}

      rulez:
        cwl: |
          rulez:
            version: 1

          parser:
            type: $graph
            driver: cwl

          onstage:
            driver: cwl

            stage_in:
              connection_node: node_stage_in
              if_scatter:
                scatterMethod: dotproduct
              input:
                template:
                  overwrite: True

            on_stage:
              connection_node: on_stage

            stage_out:
              connection_node: node_stage_out
              scatter: False
              if_scatter:
                scatterMethod: dotproduct
              follow_node: node_metrics_out


          output:
            driver: cwl
            name: '-'
            type: $graph


          cwl:
            GlobalInput:
              Directory: string
              Directory[]: string[]

            OptionalInput:
              Directory: string?
              Directory[]: string[]?

            stage_in:
              Directory:
                type: string
                inputBinding:
                  position: 2

              Directory[]:
                type: string[]
                inputBinding:
                  position: 2

            stage_out:
              Directory:
                type: Directory

              Directory[]:
                type: Directory[]

            outputBindingResult:
              command:
                Directory:
                  outputBinding:
                    glob: .
                  type: Directory
                Directory[]:
                  outputBinding:
                    glob: .
                  type: Directory[]
              stepOut:
                type:
                  items: Directory
                  type: array



      # kubernetes storage class to be used for provisioning volumes. Must be a persistent volume claim compliant (glusterfs-storage)
      processingStorageClass: managed-nfs-storage
      # Size of the Kubernetes Tmp Volumes
      processingVolumeTmpSize: "6Gi"
      # Size of the Kubernetes Output Volumes
      processingVolumeOutputSize: "6Gi"
      # Max ram to use for a job
      processingMaxRam: "8Gi"
      # Max number of CPU cores to use concurrently for a job
      processingMaxCores: "4"
      # if false the Ades will clean the volume after the workflow has successfully finished running
      processingKeepWorkspace: "false"
      processingKeepWorkspaceIfFailed: "True"
      # image pull secrects
      imagePullSecrets: []

      pod:
        env: {}

      # custom backoff limit for calrissian job
      backofflimit: 2
      
        
    wps:
      pepBaseUrl: "http://ades-pep:5576"
      usePep: "false"
      maincfgtpl: "files/main.cfg.tpl"
    persistence:
      enabled: true
      # existingUserDataClaim:
      # existingProcServicesClaim:
      storageClass: "managed-nfs-storage"
      userDataAccessMode: ReadWriteOnce
      userDataSize: 10Gi
      procServicesAccessMode: ReadWriteOnce
      procServicesSize: 5Gi
    # values - end
  # timeout: 25m0s
  interval: 1m0s
